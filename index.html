<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>行動FPS v2.0.1（診斷版）</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#111111">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<style>
  html, body { margin:0; padding:0; height:100%; background:#000; color:#fff; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial; touch-action:none; -webkit-user-select:none; user-select:none; overscroll-behavior:contain; }
  #game { position:fixed; inset:0; display:block; background:#000; }
  #hud { position:fixed; left:0; right:0; top:env(safe-area-inset-top,0); display:flex; justify-content:space-between; align-items:center; padding:8px 12px; pointer-events:none; font-size:14px; text-shadow:0 2px 4px rgba(0,0,0,.6); }
  #hud .badge { background:rgba(0,0,0,.35); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.15); }
  .joy { position:fixed; bottom:calc(env(safe-area-inset-bottom,0) + 18px); left:18px; width:160px; height:160px; border-radius:50%; background:radial-gradient(closest-side, rgba(255,255,255,.08), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.15); touch-action:none; }
  .knob { position:absolute; left:50%; top:50%; width:72px; height:72px; margin-left:-36px; margin-top:-36px; border-radius:50%; background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.85), rgba(255,255,255,.4)); border:1px solid rgba(255,255,255,.35); }
  .btn { position:fixed; bottom:calc(env(safe-area-inset-bottom,0) + 26px); width:92px; height:92px; border-radius:50%; border:1px solid rgba(255,255,255,.25); box-shadow:0 6px 18px rgba(255,0,0,.25); touch-action:none; }
  .btn:active { transform:scale(0.96); }
  #fire { right:18px; background:radial-gradient(circle at 30% 30%, rgba(255,0,0,.9), rgba(255,0,0,.5)); }
  #interact { right:128px; background:radial-gradient(circle at 30% 30%, rgba(0,153,255,.9), rgba(0,153,255,.5)); }
  #hint { position:fixed; left:50%; bottom:calc(env(safe-area-inset-bottom,0) + 12px); transform:translateX(-50%); font-size:12px; opacity:.85; background:rgba(0,0,0,.5); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.15); }
  #lookArea { position:fixed; right:0; top:0; bottom:0; width:65%; }
  #reticle { position:fixed; left:50%; top:50%; width:18px; height:18px; margin-left:-9px; margin-top:-9px; pointer-events:none; opacity:.8; }
  #reticle:before, #reticle:after { content:''; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); }
  #reticle:before { width:18px; height:2px; background:#fff; box-shadow:0 0 6px rgba(255,255,255,.5); }
  #reticle:after { width:2px; height:18px; background:#fff; box-shadow:0 0 6px rgba(255,255,255,.5); }
  #pause { position:fixed; right:12px; top:12px; background:rgba(0,0,0,.4); border:1px solid rgba(255,255,255,.2); border-radius:8px; padding:6px 8px; }
  #overlay { position:fixed; left:0; top:0; right:0; bottom:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.8); color:#fff; z-index:10; padding:24px; text-align:center; }
  #overlay pre { text-align:left; white-space:pre-wrap; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.15); padding:12px; border-radius:8px; max-height:40vh; overflow:auto; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="reticle"></div>
<div id="hud"><div class="badge" id="stat">HP 100 | 子彈 30 | 得分 0</div><div class="badge" id="fps">FPS</div></div>
<div id="joyL" class="joy"><div id="knobL" class="knob"></div></div>
<div id="lookArea"></div>
<div id="pause" class="badge">暫停</div>
<div id="fire" class="btn" title="射擊"></div>
<div id="interact" class="btn" title="互動"></div>
<div id="hint">提示：右側輕點射擊、滑動轉向；左側搖桿移動。若畫面長期全黑，點一下畫面或用 ?debug=1 重新載入。</div>

<div id="overlay">
  <div>
    <h3>初始化失敗（診斷資訊）</h3>
    <p>請把以下訊息貼給我：</p>
    <pre id="errlog"></pre>
    <button id="reload">重新載入（跳過快取）</button>
  </div>
</div>

<script>
(function(){
'use strict';
const overlay = document.getElementById('overlay');
const errlog = document.getElementById('errlog');
const reloadBtn = document.getElementById('reload');
reloadBtn.onclick = () => {
  const u = new URL(location.href);
  u.searchParams.set('debug','1');
  u.searchParams.set('t', Date.now());
  location.href = u.toString();
};

function showError(e){
  overlay.style.display = 'flex';
  errlog.textContent = e instanceof Error ? (e.stack || e.message) : String(e);
}

// Draw a boot screen to avoid "blank"
try {
  const boot = document.getElementById('game').getContext('2d');
  boot.fillStyle = '#0b0b0b'; boot.fillRect(0,0,boot.canvas.width,boot.canvas.height);
  boot.fillStyle = '#9acd32'; boot.font = '20px system-ui'; boot.fillText('載入中… v2.0.1', 12, 28);
} catch(e){ /* ignore */ }

// Main game in try/catch to surface errors on-screen
try {
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d',{alpha:false});
  let DPR=Math.max(1,Math.min(3,window.devicePixelRatio||1));
  function resize(){ const w=Math.max(window.innerWidth,320), h=Math.max(window.innerHeight,320); canvas.width=Math.floor(w*DPR); canvas.height=Math.floor(h*DPR); canvas.style.width=w+'px'; canvas.style.height=h+'px'; renderW=Math.floor(canvas.width/renderScale); renderH=Math.floor(canvas.height/renderScale); zBuffer=new Float32Array(renderW);} window.addEventListener('resize',resize,{passive:true});

  // WebAudio
  let audioCtx=null; function ensureAudio(){ if(!audioCtx){ try{ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } }
  function beep(f=600,d=.06,t='square',g=.02){ if(!audioCtx) return; const o=audioCtx.createOscillator(), x=audioCtx.createGain(); o.type=t; o.frequency.value=f; x.gain.value=g; o.connect(x).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+d); }
  const shootSound=()=>{ beep(820,.04,'square',.03); beep(420,.06,'sawtooth',.02); };
  const hitSound=()=>beep(180,.05,'triangle',.035);
  const pickupSound=()=>beep(1000,.06,'sine',.03);

  // Map
  const MAP_W=16, MAP_H=16;
  const world=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,1, 1,0,1,0,1,0,1,0,0,0,2,0,1,0,0,1, 1,0,1,0,1,0,1,0,0,0,2,0,1,0,0,1, 1,0,0,0,0,0,1,0,0,0,2,0,0,0,0,1, 1,0,1,1,1,0,1,0,0,0,2,0,1,1,0,1, 1,0,0,0,1,0,0,0,3,3,3,0,0,1,0,1, 1,0,1,0,1,0,1,0,3,0,0,0,1,1,0,1,  1,0,1,0,0,0,1,0,3,0,0,0,0,0,0,1, 1,0,1,1,1,0,1,0,3,0,0,1,1,1,0,1, 1,0,0,0,1,0,0,0,3,3,0,0,0,1,0,1, 1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,1, 1,0,1,0,0,0,1,0,0,0,0,0,0,0,9,1, 1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1, 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
  function tile(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return 1; return world[(y|0)*MAP_W + (x|0)]; }
  function setTile(x,y,v){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return; world[(y|0)*MAP_W + (x|0)] = v; }

  const player={ x:2.5, y:2.5, dir:0, fov:Math.PI/3, hp:100, ammo:30, score:0 };
  const enemies=[ {x:9.5,y:6.5,hp:40,alive:true},{x:12.5,y:10.5,hp:40,alive:true},{x:14.5,y:14.5,hp:60,alive:true} ];
  const items=[ {x:4.5,y:4.5,type:'ammo',taken:false},{x:10.5,y:2.5,type:'med',taken:false} ];

  let renderScale=2.2, renderW=0, renderH=0, zBuffer=new Float32Array(1); resize();

  const joyL=document.getElementById('joyL'), knobL=document.getElementById('knobL');
  const lookArea=document.getElementById('lookArea'), fireBtn=document.getElementById('fire'), interactBtn=document.getElementById('interact');
  const statEl=document.getElementById('stat'), fpsEl=document.getElementById('fps'), hintEl=document.getElementById('hint');
  const pauseBtn=document.getElementById('pause');
  let moveVec={x:0,y:0}, lookActive=false, lastLookX=0, shootCooldown=0, paused=false;

  function onJoyLStart(e){
    ensureAudio();
    const t=e.changedTouches? e.changedTouches[0] : e;
    joyL.dataset.active='1'; updateKnob(t);
    window.addEventListener('pointermove', onJoyLMove);
    window.addEventListener('pointerup', onJoyLEnd, { once:true });
    window.addEventListener('touchmove', onJoyLMove, { passive:false });
    window.addEventListener('touchend', onJoyLEnd, { once:true });
  }
  function updateKnob(e){
    const rect=joyL.getBoundingClientRect();
    const cx=rect.left+rect.width/2, cy=rect.top+rect.height/2;
    const dx=(e.clientX-cx), dy=(e.clientY-cy);
    const r=rect.width/2-10, mag=Math.hypot(dx,dy);
    const ndx=(mag>r? dx/mag*r:dx), ndy=(mag>r? dy/mag*r:dy);
    knobL.style.transform=`translate(${ndx}px, ${ndy}px)`;
    moveVec.x=ndx/r; moveVec.y=ndy/r;
  }
  function onJoyLMove(e){ const t=e.changedTouches? e.changedTouches[0] : e; updateKnob(t); e.preventDefault(); }
  function onJoyLEnd(){ knobL.style.transform='translate(0px,0px)'; moveVec.x=moveVec.y=0; joyL.dataset.active='0'; window.removeEventListener('pointermove', onJoyLMove); }

  joyL.addEventListener('pointerdown', onJoyLStart);
  joyL.addEventListener('touchstart', (e)=>{ onJoyLStart(e); e.preventDefault(); }, {passive:false});

  let sensitivityBase = Math.max(0.0025, Math.min(0.0045, 0.003 * (window.innerWidth/375)));
  lookArea.addEventListener('pointerdown', (e)=>{
    ensureAudio(); lookActive=true; lastLookX=e.clientX;
    window.addEventListener('pointermove', onLookMove);
    window.addEventListener('pointerup', onLookEnd, { once:true });
  });
  function onLookMove(e){ if(!lookActive) return; const dx=e.clientX-lastLookX; lastLookX=e.clientX; player.dir += dx * sensitivityBase; }
  function onLookEnd(){ lookActive=false; window.removeEventListener('pointermove', onLookMove); }
  lookArea.addEventListener('pointerup', (e)=>{ if (Math.abs(e.clientX-lastLookX) < 6) tryShoot(); });

  fireBtn.addEventListener('pointerdown', ()=>{ ensureAudio(); tryShoot(); });
  interactBtn.addEventListener('pointerdown', ()=>{ ensureAudio(); tryInteract(); });
  pauseBtn.addEventListener('pointerdown', ()=>{ paused = !paused; pauseBtn.textContent = paused ? '繼續' : '暫停'; });

  window.addEventListener('keydown', (e)=>{ if (e.code==='Space') tryShoot(); });

  function tryInteract(){
    const tx=Math.floor(player.x + Math.cos(player.dir)*1.0);
    const ty=Math.floor(player.y + Math.sin(player.dir)*1.0);
    if (tile(tx,ty)===9){ setTile(tx,ty,0); pickupSound(); }
  }
  function tryShoot(){
    if (shootCooldown>0 || player.ammo<=0) return;
    shootCooldown=0.2; player.ammo--; shootSound();
    const center=Math.floor(renderW/2), wallDist=zBuffer[center]||1e9;
    let best=null, bestDist=1e9;
    for (const e of enemies) if (e.alive){
      const dx=e.x-player.x, dy=e.y-player.y, dist=Math.hypot(dx,dy);
      const a=Math.atan2(Math.sin(Math.atan2(dy,dx)-player.dir), Math.cos(Math.atan2(dy,dx)-player.dir));
      if (Math.abs(a)<0.07 && dist<wallDist+0.1) if (dist<bestDist){ best=e; bestDist=dist; }
    }
    if (best){ best.hp-=30; hitSound(); if(best.hp<=0){ best.alive=false; player.score+=100; } }
  }
  function movePlayer(dt){
    const speed=2.1;
    const forward=-moveVec.y, strafe=moveVec.x;
    const cos=Math.cos(player.dir), sin=Math.sin(player.dir);
    const stepX=(forward*cos + strafe*(-sin)) * speed * dt;
    const stepY=(forward*sin + strafe*( cos)) * speed * dt;
    const nx=player.x+stepX; if (tile(nx,player.y)===0) player.x=nx;
    const ny=player.y+stepY; if (tile(player.x,ny)===0) player.y=ny;
    for (const it of items) if (!it.taken){
      if (Math.hypot(it.x-player.x, it.y-player.y) < 0.5){
        it.taken=true; if (it.type==='ammo') player.ammo+=12; if (it.type==='med') player.hp=Math.min(100, player.hp+25); pickupSound();
      }
    }
  }
  function updateEnemies(dt){
    for (const e of enemies) if (e.alive){
      const dx=player.x-e.x, dy=player.y-e.y, dist=Math.hypot(dx,dy);
      if (dist<8.0){ const s=1.1*dt, dirx=dx/(dist||1), diry=dy/(dist||1);
        const nx=e.x+dirx*s, ny=e.y+diry*s; if (tile(nx,e.y)===0) e.x=nx; if (tile(e.x,ny)===0) e.y=ny;
      }
      if (dist<0.6) player.hp=Math.max(0, player.hp - 10*dt);
    }
  }

  function castAndRender(){
    const W=renderW, H=renderH, w=canvas.width, h=canvas.height, scaleX=w/W, scaleY=h/H;
    const sky=ctx.createLinearGradient(0,0,0,h/2); sky.addColorStop(0,'#151a26'); sky.addColorStop(1,'#273047'); ctx.fillStyle=sky; ctx.fillRect(0,0,w,h/2);
    const floor=ctx.createLinearGradient(0,h/2,0,h); floor.addColorStop(0,'#1f1b17'); floor.addColorStop(1,'#0d0b0a'); ctx.fillStyle=floor; ctx.fillRect(0,h/2,w,h/2);
    const angleStep=player.fov/W, start=player.dir-player.fov/2;
    const COL={1:[150,150,150],2:[90,130,200],3:[180,70,70],9:[180,120,20]};
    for (let x=0;x<W;x++){
      const a=start+x*angleStep, rx=Math.cos(a), ry=Math.sin(a);
      let mx=Math.floor(player.x), my=Math.floor(player.y);
      const ddx=Math.abs(1/(rx||1e-6)), ddy=Math.abs(1/(ry||1e-6));
      let sx,sdx,sy,sdy;
      if(rx<0){sx=-1; sdx=(player.x-mx)*ddx;} else {sx=1; sdx=(mx+1.0-player.x)*ddx;}
      if(ry<0){sy=-1; sdy=(player.y-my)*ddy;} else {sy=1; sdy=(my+1.0-player.y)*ddy;}
      let hit=0, side=0, id=0, saf=0;
      while(!hit && saf++<128){
        if (sdx<sdy){ sdx+=ddx; mx+=sx; side=0; } else { sdy+=ddy; my+=sy; side=1; }
        id=tile(mx,my); if (id>0) hit=1;
      }
      let dist;
      if (!hit) dist=1e6;
      else if (side===0) dist=(mx-player.x+(1-sx)/2)/(rx||1e-6);
      else dist=(my-player.y+(1-sy)/2)/(ry||1e-6);
      if (dist<1e-4) dist=1e-4;
      zBuffer[x]=dist;
      const lineH=Math.min(H, Math.floor(H/dist)), y0=Math.floor(H/2-lineH/2);
      const base=COL[id]||[130,130,130], shade=1.0/(1.0+dist*0.3)*(side?0.8:1.0);
      const r=Math.floor(base[0]*shade), g=Math.floor(base[1]*shade), b=Math.floor(base[2]*shade);
      ctx.fillStyle=`rgb(${r},${g},${b})`;
      ctx.fillRect(Math.floor(x*scaleX), Math.floor(y0*scaleY), Math.ceil(scaleX), Math.ceil(lineH*scaleY));
    }
    const sprites=[]; for (const it of items) if(!it.taken) sprites.push({x:it.x,y:it.y,type:it.type,dist:0,kind:'item'});
    for (const e of enemies) if(e.alive) sprites.push({x:e.x,y:e.y,hp:e.hp,dist:0,kind:'enemy'});
    for (const s of sprites){ const dx=s.x-player.x, dy=s.y-player.y; s.dist=Math.hypot(dx,dy); s.angle=Math.atan2(Math.sin(Math.atan2(dy,dx)-player.dir), Math.cos(Math.atan2(dy,dx)-player.dir)); }
    sprites.sort((a,b)=> b.dist - a.dist);
    for (const s of sprites){
      if (Math.abs(s.angle)>player.fov/1.5) continue;
      const projX=(0.5 + (s.angle / player.fov)) * renderW;
      const size=Math.min(renderH, Math.floor(renderH / (s.dist||1e-4))*0.8);
      const left=Math.floor((projX - size/2) * (canvas.width/renderW));
      const top =Math.floor((renderH*0.5 - size/2) * (canvas.height/renderH));
      const w =Math.ceil(size * (canvas.width/renderW));
      const h =Math.ceil(size * (canvas.height/renderH));
      const cx=Math.floor(projX); if (cx>=0&&cx<renderW && s.dist>zBuffer[cx]+0.02) continue;
      if (s.kind==='enemy'){
        ctx.fillStyle='rgba(255, 220, 120, 0.95)';
        ctx.fillRect(left + w*0.25, top + h*0.15, w*0.5, h*0.7);
        ctx.fillStyle='rgba(60, 50, 40, 0.95)';
        ctx.fillRect(left + w*0.3, top + h*0.25, w*0.15, h*0.18);
        ctx.fillRect(left + w*0.45, top + h*0.25, w*0.15, h*0.18);
        const hpw=Math.max(1, Math.floor(w*0.6*(s.hp/60))); ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(left+w*0.2, top-8, w*0.6, 4);
        ctx.fillStyle='rgba(255,60,60,.9)'; ctx.fillRect(left+w*0.2, top-8, hpw, 4);
      } else {
        ctx.fillStyle=s.type==='ammo' ? 'rgba(120,200,255,.95)' : 'rgba(120,255,160,.95)';
        ctx.fillRect(left + w*0.35, top + h*0.35, w*0.3, h*0.3);
      }
    }
  }

  let last=performance.now(), fpsS=0, fpsC=0, firstFrame=false;
  function loop(now){
    const dt=Math.min(0.05, (now-last)/1000); last=now;
    shootCooldown=Math.max(0, shootCooldown - dt);
    movePlayer(dt); updateEnemies(dt); castAndRender();
    document.getElementById('stat').textContent=`HP ${Math.round(player.hp)} | 子彈 ${player.ammo} | 得分 ${player.score}`;
    fpsS+=1; fpsC+=dt; if (fpsC>=0.5){ const fps=Math.round(fpsS/fpsC); document.getElementById('fps').textContent=`FPS ${fps}`; fpsS=0; fpsC=0; }
    if (!firstFrame){ firstFrame=true; document.getElementById('hint').textContent='右側輕點射擊、滑動轉向；左側搖桿移動。'; }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  setTimeout(()=>{ const x=document.getElementById('hint'); if(x) x.style.opacity='0'; }, 6000);
  window.addEventListener('gesturestart', (e)=> e.preventDefault());
  window.addEventListener('contextmenu', (e)=> e.preventDefault());
  document.addEventListener('touchmove', (e)=> e.preventDefault(), {passive:false});
  window.addEventListener('pointerdown', ensureAudio, { once: true });

  const fpsEl=document.getElementById('fps');
  const old=fpsEl.textContent;
  setTimeout(()=>{
    if (fpsEl.textContent===old){
      const msg='渲染循環未啟動，可能是舊版快取或初始化錯誤。請點「重新載入（跳過快取）」，或清除此站資料。';
      const overlay = document.getElementById('overlay');
      const errlog = document.getElementById('errlog');
      overlay.style.display='flex'; errlog.textContent=msg;
    }
  }, 2000);

} catch(e){
  const overlay = document.getElementById('overlay');
  const errlog = document.getElementById('errlog');
  overlay.style.display='flex'; errlog.textContent = e.stack || e.message || String(e);
}
})();</script>

<script>
(function(){
  if (!('serviceWorker' in navigator)) return;
  const url = new URL(location.href);
  if (url.searchParams.get('debug') === '1') {
    console.log('Debug mode: skip SW registration.');
    return;
  }
  window.addEventListener('load', ()=>{
    navigator.serviceWorker.register('./sw.js').catch(e=>console.log('SW reg failed', e));
  });
})();
</script>
</body>
</html>
